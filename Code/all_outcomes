install.packages(c("tidyr", "tidyverse", "rnaturalearth", "rnaturalearthdata", "sf", "ggplot2", "grid", "dplyr", "patchwork", "here", 
"meta", "metafor", "clubSandwich", "robumeta", "devtools", "MASS"))

# Load necessary libraries
library(dplyr)
library(tidyr)
library(tidyverse)
library(rnaturalearth)  
library(rnaturalearthdata)
library(sf)              
library(ggplot2)
library(grid)
library(patchwork)
library(here)
library(metafor)
library(meta)
library(clubSandwich)
library(robumeta)
library(MASS)

#install.packages("pacman")
rm(list = ls())
devtools::install_github("daniel1noble/orchaRd", ref = "main", force = TRUE)
pacman::p_load(devtools, tidyverse, metafor, patchwork, R.rsp, orchaRd, emmeans, ape, phytools, flextable)

###Please download GitHub repository and then run the following
here()
mydata <- read_csv(here("GitHub", "UlvaSupplements_AbaloneMA", "Data", "Ulva inclusion in Haliotis sp. diets_A Meta-analysis - Data"))
head(mydata)

#Add another column to assign short citation
citations <- data.frame(
  study_ID = c("S001", "S002", "S003", "S004", "S005", "S006", "S007", "S008","S009", "S010", "S011"),
  short_citation = c(
    "Bansemer et al. (2016)",
    "Lange et al. (2014)",
    "Stone et al. (2022)",
    "Francis et al. (2021)",
    "Mwangudza (2024)",
    "Falade (2023)",
    "Bates et al. (2017)",
    "Chi et al. (2018)",
    "Angell et al. (2012)",
    "Searle et al. (2025)", 
    "Duong et al. (2021)" 
  ))

mydata <- mydata %>%
  left_join(citations, by = "study_ID")

#Add long outcome names
mydata <- mydata %>%
  mutate(
    outcome_long = case_when(
      outcome == "FI"  ~ "Feed intake",
      outcome == "BG"  ~ "Biomass gain",
      outcome == "CF"  ~ "Condition factor",
      outcome == "FW"  ~ "Final weight",
      outcome == "FSL" ~ "Final shell length",
      outcome == "SG"  ~ "Shell gain",
      outcome == "SGR" ~ "Specific growth rate",
      outcome == "WG"  ~ "Weight gain",
      outcome == "EER" ~ "Energy efficiency ratio",
      outcome == "ED"  ~ "Energy deposition",
      outcome == "FCR" ~ "Feed conversion ratio",
      outcome == "PER" ~ "Protein efficiency ratio",
      outcome == "PD"  ~ "Protein deposition",
      outcome == "LG"  ~ "Length gain",
      outcome == "I" ~ "Ingested feed energy", 
      outcome == "Pg" ~ "Somatic feed energy", 
      outcome == "S" ~ "Shell growth energy",
      TRUE ~ outcome
    )
  )

#Arcsine transform proportional data (protein deposition and energy deposition)
mydata <- mydata %>%
  mutate(
    arcsine_transformed = ifelse(
      outcome %in% c("Protein deposition", "Energy deposition"),
      asin(sqrt(treatment_mean / 100)),  
      NA_real_
    )
  )

# Calculate effect size (lnRR) and variance
all_data <- mydata %>%
  mutate(
    lnRR_all = log(treatment_mean / control_mean),
    vi_lnRR_all = (treatment_SD^2) / (treatment_n * treatment_mean^2) +
              (control_SD^2) / (control_n * control_mean^2)
  )

#Reverse the sign of FCR effect size
all_data <- all_data %>%
  mutate(lnRR_all = ifelse(outcome == "FCR", -lnRR_all, lnRR_all))

# Run 3-level meta-analysis
res_3L_all <- rma.mv(yi = lnRR_all, V = vi_lnRR_all,
                     random = ~ 1 | study_ID / ES_ID,
                     data = all_data,
                     method = "REML")
res_3L_all

#Testing effect of species
# Set species as a factor and H. laevigata as the reference (highest k)
all_data$species <- factor(all_data$species)
all_data$species <- relevel(all_data$species, ref = "H. laevigata")

# MLMA with species as fixed effect
res_species_fixed <- rma.mv(
  yi   = lnRR_all,
  V    = vi_lnRR_all,
  mods = ~ species,                    
  random = ~ 1 | study_ID / ES_ID,  
  data = all_data,
  method = "REML"
)
summary(res_species_fixed)

# MLMA with species as random effect
res_species_random <- rma.mv(
yi   = lnRR_all,
V    = vi_lnRR_all,
  random = list(
    ~ 1 | species,                  
    ~ 1 | study_ID / ES_ID 
  ),
  data = all_data,
  method = "REML"
)
summary(res_species_random)

# Compare models
anova(res_3L_all, res_species_random)

# Extract variance components
sigma_study_all   <- res_3L_all$sigma2[1]
sigma_exp_all    <- res_3L_all$sigma2[2]

# Mean sampling variance
mean_vi_all <- mean(all_data$vi_lnRR_all)

# Total variance
total_var_all <- sigma_study_all + sigma_exp_all + mean_vi_all

# I² calculations
I2_study_all   <- sigma_study_all   / total_var_all * 100
I2_exp_all    <- sigma_exp_all     / total_var_all * 100
I2_total_all   <- (sigma_species_all + sigma_study_all + sigma_exp_all) / total_var_all * 100

I2_study_all; I2_exp_all; I2_total_all

#Plot orchard plot
orchaRd::orchard_plot(
    res_species_random,
    mod = "1",
    xlab = "Effect Size (Hedges g)",
    group = "study_ID"
) +
  annotate(
    geom = "text",
    x = 0.7,
    y = 10,
    label = paste0("italic(I)^{2} == ", round(I2_total[1], 2), "*\"%\""),
    color = "black",
    parse = TRUE,
    size = 5
  ) +
  scale_fill_manual(values = "grey") +
  scale_colour_manual(values = "grey")

#Publication bias
# Compute SE, precision, and effective sample size for all_data
all_data <- all_data %>%
  mutate(
    se_g = sqrt(vi_lnRR_all),  
    precision = 1 / se_g,                     
    n_eff = (treatment_n * control_n) / (treatment_n + control_n),
    inv_n_eff = 1 / n_eff                  
  )

# Fit three-level MLMA with precision as moderator
res_bias_precision_all <- rma.mv(
  yi   = lnRR_all,
  V    = vi_lnRR_all,
  mods = ~ precision,                       
  random = list(                  
    ~ 1 | study_ID / ES_ID 
  ), 
  data = all_data,
  method = "REML")
summary(res_bias_precision_all)

# Robust small-sample corrected test for the moderator (CR2, Satterthwaite df)
cr2_test_precision <- coef_test(
  res_bias_precision_all,
  vcov = "CR2",
  cluster = all_data$study_ID,
  test = "Satterthwaite"
)
print(cr2_test_precision)




# Create funnel plot
#Calculate SE
all_data <- all_data %>%
  mutate(SE = 1 / precision)

# Create a grid of precision values for plotting the funnel
precision_grid <- seq(min(all_data$precision), max(all_data$precision), length.out = 100)

# Pooled effect (mean lnRR)
mean_lnRR <- mean(all_data$lnRR_all, na.rm = TRUE)

# Upper and lower bounds
bounds <- data.frame(
  precision = precision_grid,
  lnRR_upper = mean_lnRR + 1.96 / precision_grid,
  lnRR_lower = mean_lnRR - 1.96 / precision_grid
)
str(bounds)

#Create plot
funnel_plot_all <- ggplot(all_data, aes(x = lnRR_all, y = precision)) +
  geom_ribbon(
  data = bounds,
  aes(xmin = lnRR_lower, xmax = lnRR_upper, y = precision),
  fill = "white",
  colour = "black",
  linetype = "dotted",
  size = 0.5,
  inherit.aes = FALSE) +
 geom_point(shape = 21, fill = "grey", color = "black", size = 3) +  
  geom_vline(xintercept = 0, linetype = "dotted", color = "black", size = 1) +
  scale_y_continuous(name = "Precision (1/SE)") +
  scale_x_continuous(name = "Effect Size (lnRR)") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major.x = element_blank(),             
    panel.grid.minor.x = element_blank(),             
    panel.grid.major.y = element_line(color = "white", size = 0.5),  
    panel.grid.minor.y = element_blank(),
    panel.background = element_rect(fill = "grey90"),  
    axis.line = element_line(color = "black", linewidth = 0.8),
    axis.ticks.length = unit(0.3, "cm"),
    axis.ticks = element_line(color = "black"),
    axis.title = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 16),
    plot.title = element_text(face = "bold", hjust = 0.01, size = 18)
  ) +
  ggtitle("")

ggsave("funnel_plot_all.png", width = 15, height = 10, units = "in")

#Run MLMR with outcome_category as a moderator
# Set growth performance as reference category (highest number of effect sizes)
all_data$outcome_category <- factor(all_data$outcome_category)  # convert to factor
all_data$outcome_category <- relevel(all_data$outcome_category, ref = "growth performance")

res_meta_reg <- rma.mv(yi = lnRR_all, V  = vi_lnRR_all,
  mods = ~ outcome_category,        
  random = list(                
    ~ 1 | study_ID / ES_ID),
  data = all_data,
  method = "REML"
)
res_meta_reg

# Extract variance components
sigma_study_all_outcome   <- res_meta_reg$sigma2[1]
sigma_exp_all_outcome    <- res_meta_reg$sigma2[2]

# Mean sampling variance
mean_vi_all <- mean(all_data$vi_lnRR_all)

# Total variance
total_var_all_outcome <- sigma_study_all_outcome + sigma_exp_all_outcome + mean_vi_all

# I² calculations
I2_study_all_outcome   <- sigma_study_all_outcome   / total_var_all_outcome * 100
I2_exp_all_outcome    <- sigma_exp_all_outcome     / total_var_all_outcome * 100
I2_total_all_outcome   <- (sigma_study_all_outcome + sigma_exp_all_outcome) / total_var_all_outcome * 100

I2_study_all_outcome; I2_exp_all_outcome; I2_total_all_outcome
