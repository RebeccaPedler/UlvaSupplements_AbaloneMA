install.packages(c("tidyr", "tidyverse", "rnaturalearth", "rnaturalearthdata", "sf", "ggplot2", "grid", "dplyr", "patchwork", "here", "meta", "metafor", "clubSandwich", "robumeta", "devtools"))

# Load necessary libraries
library(dplyr)
library(tidyr)
library(tidyverse)
library(rnaturalearth)   # for map data
library(rnaturalearthdata)
library(sf)              # for spatial handling
library(ggplot2)
library(grid)
library(patchwork)
library(here)
library(metafor)
library(meta)
library(clubSandwich)
library(robumeta)

#install.packages("pacman")
rm(list = ls())
devtools::install_github("daniel1noble/orchaRd", ref = "main", force = TRUE)
pacman::p_load(devtools, tidyverse, metafor, patchwork, R.rsp, orchaRd, emmeans, ape, phytools, flextable)

###Please download GitHub repository and then run the following
here()
mydata <- read_csv(here("GitHub", "UlvaSupplements_AbaloneMA", "Data", "Ulva inclusion in Haliotis sp. diets_A Meta-analysis - Data"))
head(mydata)

#Add another column to assign short citation
citations <- data.frame(
  study_ID = c("S001", "S002", "S003", "S004", "S005", "S006", "S007", "S008","S009", "S010", "S011"),
  short_citation = c(
    "Bansemer et al. (2016)",
    "Lange et al. (2014)",
    "Stone et al. (2022)",
    "Francis et al. (2021)",
    "Mwangudza (2024)",
    "Falade (2023)",
    "Bates et al. (2017)",
    "Chi et al. (2018)",
    "Angell et al. (2012)",
    "Searle et al. (2025)", 
    "Duong et al. (2021)" 
  ))

mydata <- mydata %>%
  left_join(citations, by = "study_ID")

#Add long outcome names
mydata <- mydata %>%
  mutate(
    outcome_long = case_when(
      outcome == "FI"  ~ "Feed intake",
      outcome == "BG"  ~ "Biomass gain",
      outcome == "CF"  ~ "Condition factor",
      outcome == "FW"  ~ "Final weight",
      outcome == "FSL" ~ "Final shell length",
      outcome == "SG"  ~ "Shell gain",
      outcome == "SGR" ~ "Specific growth rate",
      outcome == "WG"  ~ "Weight gain",
      outcome == "EER" ~ "Energy efficiency ratio",
      outcome == "ED"  ~ "Energy deposition",
      outcome == "FCR" ~ "Feed conversion ratio",
      outcome == "PER" ~ "Protein efficiency ratio",
      outcome == "PD"  ~ "Protein deposition",
      outcome == "LG"  ~ "Length gain",
      outcome == "I" ~ "Ingested feed energy", 
      outcome == "Pg" ~ "Somatic feed energy", 
      outcome == "S" ~ "Shell growth energy",
      TRUE ~ outcome
    )
  )

#########Feed behaviour
# Filter for feed behaviour
feed_data <- mydata %>%
  filter(outcome_category == "feed behaviour")
print(feed_data)

# Calculate effect size (Hedges g) and pooled SD
feed_data <- feed_data %>%
  mutate(
    s_pooled_feed = sqrt(((treatment_n - 1) * treatment_SD^2 + (control_n - 1) * control_SD^2) /
                    (treatment_n + control_n - 2)),
    J_feed = 1 - (3 / (4 * (treatment_n + control_n) - 9)),
    g_feed = J_feed * ((treatment_mean - control_mean) / s_pooled_feed),
    vi_g_feed = (treatment_n + control_n) / (treatment_n * control_n) + (g_feed^2 / (2 * (treatment_n + control_n - 2)))
  )

res_3L_feed <- rma.mv(yi = g_feed, V = vi_g_feed,
                 random = ~ 1 | study_ID / experiment_ID,
                 data = feed_data,
                 method = "REML")

# Extract variance components
sigma_study <- res_3L_feed$sigma2[1]   # between-study
sigma_exp   <- res_3L_feed$sigma2[2]   # within-study / experimental

# Mean sampling variance
mean_vi_feed <- mean(feed_data$vi_g_feed)

# Calculate IÂ²
I2_study <- sigma_study / (sigma_study + sigma_exp + mean_vi_feed) * 100
I2_exp   <- sigma_exp / (sigma_study + sigma_exp + mean_vi_feed) * 100
I2_total <- (sigma_study + sigma_exp) / (sigma_study + sigma_exp + mean_vi_feed) * 100

I2_study; I2_exp; I2_total

# Orchard plot (overall effect)
I2 <- orchaRd::i2_ml(res_3L_feed) #Defining I2 so that it can be printed on the graph
orchaRd::orchard_plot(
    res_3L_feed,
    mod = "1",
    xlab = "Effect Size (Hedges g)",
    group = "study_ID"
) +
  annotate(
    geom = "text",
    x = 0.7,
    y = 10,
    label = paste0("italic(I)^{2} == ", round(I2[1], 4), "*\"%\""),
    color = "black",
    parse = TRUE,
    size = 5
  ) +
  scale_fill_manual(values = "grey") +
  scale_colour_manual(values = "grey")

#Publication bias
# Compute SE, precision (1/SE), and an "effective sample size"
feed_data <- feed_data %>%
  mutate(
    se_g = sqrt(vi_g_feed),                    # standard error of effect size
    precision = 1 / se_g,                     
    n_eff = (treatment_n * control_n) / (treatment_n + control_n),
    inv_n_eff = 1 / n_eff                       # inverse effective sample size (not sqrt)
  )

# Fit three-level MLMA with precision as moderator
res_bias_precision_feed <- rma.mv(
  yi   = g_feed,
  V    = vi_g_feed,
  mods = ~ precision,                          
  random = ~ 1 | study_ID / experiment_ID,    
  data = feed_data,
  method = "REML"
)
summary(res_bias_precision_feed)

# Robust small-sample corrected test for the moderator (CR2, Satterthwaite df)
cr2_test_precision <- coef_test(
  res_bias_precision_feed,
  vcov = "CR2",
  cluster = feed_data$study_ID,
  test = "Satterthwaite"
)
print(cr2_test_precision)

# Create funnel plot data frame
funnel_data <- feed_data %>%
  mutate(
    se_g = sqrt(vi_g_feed),
    precision = 1 / se_g
  )

# Funnel plot
ggplot(feed_data, aes(x = g_feed, y = precision)) +
  geom_point(shape = 21, fill = "grey", color = "black", size = 3) +  # points
  geom_vline(xintercept = 0, linetype = "dotted", color = "black", size = 1) +  # vertical line at 0
  scale_y_continuous(name = "Precision (1/SE)") +
  scale_x_continuous(name = "Effect Size (Hedges g)") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.8),
    axis.ticks.length = unit(0.3, "cm"),
    axis.ticks = element_line(color = "black"),
    plot.title = element_text(face = "bold", hjust = 0.01)
  ) +
  ggtitle("A) Feed Behaviour")

#Testing impact of moderators independantly (both linear and quadratic terms for continious data)
res_size <- rma.mv(yi = g_feed, V = vi_g_feed, mods = ~ initial_size_g + I(initial_size_g^2), random = ~ 1 | study_ID / experiment_ID, data = feed_data)
summary(res_size)
res_3L_feed_quad <- rma.mv(yi = g_feed, V = vi_g_feed, mods = ~ intervention_dose + I(intervention_dose^2), random = ~ 1 | study_ID / experiment_ID, data = feed_data)
summary(res_3L_feed_quad)
res_prep <- rma.mv(yi = g_feed, V = vi_g_feed, mods = ~ intervention_preparation, random = ~ 1 | study_ID / experiment_ID, data = feed_data)
summary(res_prep)
res_species <- rma.mv(yi = g_feed, V = vi_g_feed, mods = ~ species, random = ~ 1 | study_ID / experiment_ID, data = feed_data)
summary(res_species)

res_feed_combined <- rma.mv(
  yi = g_feed,
  V  = vi_g_feed,
  mods = ~ intervention_dose + I(intervention_dose^2) + intervention_preparation,
  random = ~ 1 | study_ID / experiment_ID,
  data = feed_data,
  method = "REML"
)
summary(res_feed_combined)

#Calculating optimum Ulva dose for feed_behaviour using the res_feed_combined model
# Extract coefficients
beta0 <- coef(res_feed_combined)["intrcpt"]
beta1 <- coef(res_feed_combined)["intervention_dose"]
beta2 <- coef(res_feed_combined)["I(intervention_dose^2)"]
beta_prep <- coef(res_feed_combined)["intervention_preparationmeal"]

# Optimum dose
opt_dose <- -beta1 / (2 * beta2)
opt_dose

# Variance-covariance for linear and quadratic dose
vc <- vcov(res_feed_combined)[c("intervention_dose","I(intervention_dose^2)"),
                               c("intervention_dose","I(intervention_dose^2)")]

# Delta method
d_b1 <- -1 / (2 * beta2)
d_b2 <- beta1 / (2 * beta2^2)

var_opt <- d_b1^2 * vc["intervention_dose","intervention_dose"] +
           d_b2^2 * vc["I(intervention_dose^2)","I(intervention_dose^2)"] +
           2 * d_b1 * d_b2 * vc["intervention_dose","I(intervention_dose^2)"]

se_opt <- sqrt(var_opt)

ci_opt <- c(
  optimum_dose_percent = opt_dose,
  CI_lower = opt_dose - 1.96 * se_opt,
  CI_upper = opt_dose + 1.96 * se_opt
)
ci_opt

coefs <- coef(res_feed_combined)[c("intervention_dose","I(intervention_dose^2)")]
vc <- vcov(res_feed_combined)[c("intervention_dose","I(intervention_dose^2)"),
                               c("intervention_dose","I(intervention_dose^2)")]
n_sims <- 10000
sim_coefs <- mvrnorm(n_sims, mu = coefs, Sigma = vc)
opt_sims <- -sim_coefs[,1] / (2 * sim_coefs[,2])

pred_opt <- beta0 + beta1*opt_dose + beta2*opt_dose^2 + beta_prep
pred_opt

beta0_sim <- coef(res_feed_combined)["intrcpt"]
beta_prep_sim <- coef(res_feed_combined)["intervention_preparationmeal"]

# Combine into simulation
full_coefs <- cbind(
  beta0 = beta0_sim <- rnorm(n_sims, mean=beta0, sd=sqrt(vcov(res_feed_combined)["intrcpt","intrcpt"])),
  beta1 = sim_coefs[,1],
  beta2 = sim_coefs[,2],
  beta_prep = rnorm(n_sims, mean=beta_prep, sd=sqrt(vcov(res_feed_combined)["intervention_preparationmeal","intervention_preparationmeal"]))
)
pred_sims <- full_coefs[,1] + full_coefs[,2]*opt_sims + full_coefs[,3]*opt_sims^2 + full_coefs[,4]
quantile(pred_sims, probs = c(0.025,0.975))


